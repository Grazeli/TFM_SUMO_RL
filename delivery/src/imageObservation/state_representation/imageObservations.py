import numpy as np
from PIL import Image
import os

from observations import Observations

class ImageObservations(Observations):
    """
    Class that computes the observations as one or several images of the simulation
    In order to obtain those images the simulator saves a screenshot of the simulation at a given time

    :param library Traci: traci library to access the SUMO simulation
    :param string filepath: Temporal filepath for the screenshot generated by the simulator
    :param Configuration config: Configuration class in order to access the configuration.xml file
    :return: None
    """
    def __init__(self, traci, filepath: str, config):
        super().__init__(traci)

        self.screenshot = list(map(int, config.get(['observations', 'screenshot']).split()))

        self.filepath =  os.getcwd() + '/' + filepath

        self.screenshot_pending = False


    def _cleanup(self):
        """
        Internal function to cleanup after the computation of the observations

        :return: None
        """
        self.screenshot_pending = False
        self.observations = np.array([])


    def _make_screenshot(self):
        """
        Internal function that calls the Traci screenshot function and does the necessary status changes

        :return: None
        """
        if self.screenshot_pending:
            self._save_screenshot()

        self.traci.gui.screenshot("View #0", self.filepath)
        self.screenshot_pending = True


    def _save_screenshot(self):
        """
        Saves into the observations class attribute a previously executed screenshot

        :return: None (Updates the observations class attribute)
        """
        # Read image into numby after conversion to grayscale and resizing
        pil_image = Image.open(self.filepath).convert('L')
        pil_image = pil_image.resize((int(pil_image.size[0] / 2), int(pil_image.size[1] / 2)), Image.ANTIALIAS)
        img = np.array(pil_image)

        # Normalize
        img = img / 255

        img = np.reshape(img, (img.shape[0], img.shape[1], 1))

        # Save in self._observations
        if self.observations.size == 0:
            self.observations = img
        else:
            self.observations = np.concatenate((self.observations, img), axis=2)

        self.screenshot_pending = False


    def _compute_observations(self):
        """
        Internal function to compute the observations

        :return: The state representation / observations
        """
        if self.screenshot_pending:
            self._save_screenshot()

        aux = self.observations

        self._cleanup()

        return aux


    def step(self, step: int):
        """
        Function called at each time step, required for some observations implementation

        :param int step: The sumo simulation step
        :return: None
        """
        if self.screenshot_pending:
            self._save_screenshot()

        if (step % 60) in self.screenshot:
            self._make_screenshot()


    def get_observations_size(self):
        """
        Function returning (if possible) the dimensions of the observations.
        It is possible that the program doesn't have that information due to the fact that we can't
        precompute it before having a example. (See report)

        :return: Either the observations shape or None if it is unknown
        """
        if self.observations.size == 0:
            return None
        else:
            return self.observations.shape


    def get_observations(self):
        """
        Function that returns the observations computed

        :return: The state representation / observations
        """
        return self._compute_observations()


from gym import spaces
import numpy as np
from PIL import Image
import os

from state_representation.observations import Observations

class ImageObservations(Observations):
    """
    Class that computes the observations as one or several images of the simulation
    In order to obtain those images the simulator saves a screenshot of the simulation at a given time

    :param library Traci: traci library to access the SUMO simulation
    :param string filepath: Temporal filepath for the screenshot generated by the simulator 
    :return: None
    """
    def __init__(self, traci, filepath):
        super().__init__(traci)

        self.filepath =  os.getcwd() + '/' + filepath
        print(self.filepath)

        self.z = 0
        self.screenshot_pending = False

    def _cleanup(self):
        """
        Internal function to cleanup after the computation of the observations

        :return: None
        """
        self.screenshot_pending = False
        self.z = 0

    def _make_screenshot(self):
        if self.screenshot_pending:
            self._save_screenshot()

        self.traci.gui.screenshot("View #0", self.filepath)
        self.screenshot_pending = True

    def _save_screenshot(self):
        """
        Saves into the observations class attribute a previously executed screenshot

        :return: None (Updates the observations class attributes)
        """
        # Read image directly into numpy with conversion to grayscale
        img = np.array(Image.open(self.filepath).convert('L'))

        # Normalize
        img = img / 255

        img = np.reshape(img, (img.shape[0], img.shape[1], 1))

        # Save in self._observations
        if self.observations.size == 0:
            self.observations = img
        else:
            self.observations = np.concatenate((self.observations, img), axis=2)

        self.z += 1
        self.screenshot_pending = False

    def _compute_observations(self):
        """
        Internal function to compute the observations

        :return: The state representation / observations
        """
        if self.screenshot_pending:
            self._save_screenshot()

        aux = self.observations

        self._cleanup()

        return aux

    def step(self, step):
        """
        Function called at each time step, required for some observations implementation

        :param int step: The sumo step
        :return: None
        """
        if self.screenshot_pending:
            self._save_screenshot()

        if step % 600 == 599:
            self._make_screenshot()


    def get_observations_size(self):
        """
        Function called at each time step, required for some observations implementation

        :param int step: The sumo step
        :return: None
        """
        if self.z == 0:
            return None
        else:
            return self.observations.shape


    def get_observations(self):
        """
        Function that returns the observations computed

        :return: The state representation / observations
        """
        return self._compute_observations()

